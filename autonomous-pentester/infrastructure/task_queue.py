import asyncio
from asyncio import Queue

class TaskQueue:
    def __init__(self, worker_count=5):
        self.queue = Queue()
        self.worker_count = worker_count
        self.workers = []

    async def worker(self, worker_id):
        while True:
            task = await self.queue.get()
            try:
                print(f"Worker {worker_id} processing task: {task['target']}")
                # Check if func is coroutine
                if asyncio.iscoroutinefunction(task['func']):
                    result = await task['func'](*task['args'], **task['kwargs'])
                else:
                    # Run sync function in thread
                    loop = asyncio.get_event_loop()
                    result = await loop.run_in_executor(None, task['func'], *task['args'])
                print(f"Worker {worker_id} completed task: {task['target']}")
                task['future'].set_result(result)
            except Exception as e:
                print(f"Worker {worker_id} error on task {task['target']}: {e}")
                task['future'].set_exception(e)
            finally:
                self.queue.task_done()

    async def start_workers(self):
        for i in range(self.worker_count):
            worker_task = asyncio.create_task(self.worker(i))
            self.workers.append(worker_task)

    async def add_task(self, func, *args, **kwargs):
        future = asyncio.get_event_loop().create_future()
        task = {
            'func': func,
            'args': args,
            'kwargs': kwargs,
            'future': future,
            'target': args[0] if args else None
        }
        await self.queue.put(task)
        return await future

    async def wait_completion(self):
        await self.queue.join()
        for w in self.workers:
            w.cancel()
